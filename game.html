<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Classic Ludo Game</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
        <style>
            .board {
                background-color: #f0f0f0;
                display: grid;
                grid-template-columns: repeat(15, 40px);
                grid-template-rows: repeat(15, 40px);
                gap: 2px;
            }
            .cell {
                width: 40px;
                height: 40px;
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative;
            }
            .home-area {
                display: grid;
                grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(6, 1fr);
            }
            .token {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                position: absolute;
                z-index: 10;
                transition: all 0.3s ease;
            }
            .player-token {
                cursor: pointer;
            }
            .dice {
                width: 50px;
                height: 50px;
                background-color: white;
                border-radius: 8px;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 24px;
                font-weight: bold;
                cursor: pointer;
                user-select: none;
                transition: transform 0.3s ease;
            }
            .dice:hover {
                transform: scale(1.1);
            }
            .dice-rolling {
                animation: roll 0.5s ease infinite;
            }
            @keyframes roll {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>
    <body class="flex min-h-screen flex-col items-center justify-center bg-gray-100 p-4">
        <div class="flex flex-col items-center gap-8 md:flex-row">
            <div class="flex flex-col items-center">
                <h1 class="mb-4 text-center text-3xl font-bold">Classic Ludo Game</h1>
                <div class="board border-2 border-gray-800 bg-white shadow-lg">
                    <!-- The board will be generated by JavaScript -->
                </div>
            </div>

            <div class="flex flex-col items-center gap-6 rounded-lg bg-white p-6 shadow-md">
                <div class="player-turn text-xl font-bold">Player's Turn: <span id="current-player" class="text-red-500">Red</span></div>

                <div id="dice" class="dice border-2 border-gray-300 shadow">1</div>

                <div class="flex flex-col gap-4">
                    <div class="flex items-center gap-2">
                        <div class="h-4 w-4 rounded-full bg-red-500"></div>
                        <span>Red: <span id="red-score">0</span> tokens home</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="h-4 w-4 rounded-full bg-green-500"></div>
                        <span>Green: <span id="green-score">0</span> tokens home</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="h-4 w-4 rounded-full bg-yellow-500"></div>
                        <span>Yellow: <span id="yellow-score">0</span> tokens home</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="h-4 w-4 rounded-full bg-blue-500"></div>
                        <span>Blue: <span id="blue-score">0</span> tokens home</span>
                    </div>
                </div>

                <button id="new-game" class="mt-4 rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">New Game</button>

                <div id="game-message" class="mt-2 text-center text-lg font-medium"></div>
            </div>
        </div>

        <script>
            // Game configuration
            const PLAYERS = ['red', 'green', 'yellow', 'blue'];
            const PLAYER_COLORS = {
                red: 'bg-red-500',
                green: 'bg-green-500',
                yellow: 'bg-yellow-500',
                blue: 'bg-blue-500',
            };
            const PLAYER_START_POSITIONS = {
                red: 0,
                green: 13,
                yellow: 26,
                blue: 39,
            };
            const PLAYER_HOME_STRETCH = {
                red: [52, 53, 54, 55, 56],
                green: [59, 60, 61, 62, 63],
                yellow: [66, 67, 68, 69, 70],
                blue: [73, 74, 75, 76, 77],
            };

            // Game state
            let gameState = {
                currentPlayer: 'red',
                currentPlayerIndex: 0,
                diceValue: 1,
                canRollAgain: true,
                tokens: {},
                scores: {
                    red: 0,
                    green: 0,
                    yellow: 0,
                    blue: 0,
                },
                selectedToken: null,
                gameOver: false,
            };

            // Board layout
            const boardLayout = [];

            // Main path positions (coordinates on the grid)
            const mainPath = [
                // Red start (bottom)
                [7, 14],
                [7, 13],
                [7, 12],
                [7, 11],
                [7, 10],
                [7, 9],
                // Bottom right corner
                [6, 8],
                [5, 8],
                [4, 8],
                [3, 8],
                [2, 8],
                [1, 8],
                [0, 8],
                // Green start (right)
                [0, 7],
                [1, 7],
                // Right side
                [2, 7],
                [3, 7],
                [4, 7],
                [5, 7],
                [6, 7],
                [7, 7],
                // Top right corner
                [8, 6],
                [8, 5],
                [8, 4],
                [8, 3],
                [8, 2],
                [8, 1],
                [8, 0],
                // Yellow start (top)
                [7, 0],
                [7, 1],
                // Top side
                [7, 2],
                [7, 3],
                [7, 4],
                [7, 5],
                [7, 6],
                [7, 7],
                // Top left corner
                [6, 8],
                [5, 8],
                [4, 8],
                [3, 8],
                [2, 8],
                [1, 8],
                [0, 8],
                // Blue start (left)
                [0, 7],
                [0, 6],
                // Left side
                [0, 5],
                [0, 4],
                [0, 3],
                [0, 2],
                [0, 1],
                [0, 0],
            ];

            // Home stretch paths
            const homeStretchPaths = {
                red: [
                    [7, 8],
                    [7, 7],
                    [7, 6],
                    [7, 5],
                    [7, 4],
                    [7, 3],
                ],
                green: [
                    [8, 7],
                    [9, 7],
                    [10, 7],
                    [11, 7],
                    [12, 7],
                    [13, 7],
                ],
                yellow: [
                    [7, 6],
                    [7, 5],
                    [7, 4],
                    [7, 3],
                    [7, 2],
                    [7, 1],
                ],
                blue: [
                    [6, 7],
                    [5, 7],
                    [4, 7],
                    [3, 7],
                    [2, 7],
                    [1, 7],
                ],
            };

            // Starting areas for tokens
            const startingAreas = {
                red: [
                    [2, 12],
                    [2, 10],
                    [4, 12],
                    [4, 10],
                ],
                green: [
                    [10, 12],
                    [12, 12],
                    [10, 10],
                    [12, 10],
                ],
                yellow: [
                    [10, 4],
                    [12, 4],
                    [10, 2],
                    [12, 2],
                ],
                blue: [
                    [2, 4],
                    [4, 4],
                    [2, 2],
                    [4, 2],
                ],
            };

            // Initialize the board
            function initializeBoard() {
                const board = document.querySelector('.board');
                board.innerHTML = '';

                // Create the 15x15 grid
                for (let y = 0; y < 15; y++) {
                    for (let x = 0; x < 15; x++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.x = x;
                        cell.dataset.y = y;

                        // Color the cell based on its position
                        if (x < 6 && y < 6) {
                            // Red area (top-left)
                            cell.classList.add('bg-red-100');
                        } else if (x > 8 && y < 6) {
                            // Green area (top-right)
                            cell.classList.add('bg-green-100');
                        } else if (x > 8 && y > 8) {
                            // Yellow area (bottom-right)
                            cell.classList.add('bg-yellow-100');
                        } else if (x < 6 && y > 8) {
                            // Blue area (bottom-left)
                            cell.classList.add('bg-blue-100');
                        } else if (x === 7 && y === 7) {
                            // Center home
                            cell.classList.add('bg-purple-200');
                        } else {
                            // Path cells
                            let isPathCell = false;

                            // Check if it's a main path cell
                            for (const [pathX, pathY] of mainPath) {
                                if (pathX === x && pathY === y) {
                                    cell.classList.add('bg-gray-200');
                                    isPathCell = true;
                                    break;
                                }
                            }

                            // Check if it's a home stretch cell
                            if (!isPathCell) {
                                for (const player in homeStretchPaths) {
                                    for (const [pathX, pathY] of homeStretchPaths[player]) {
                                        if (pathX === x && pathY === y) {
                                            cell.classList.add(`bg-${player}-200`);
                                            isPathCell = true;
                                            break;
                                        }
                                    }
                                    if (isPathCell) break;
                                }
                            }

                            // Default background
                            if (!isPathCell) {
                                cell.classList.add('bg-white');
                            }
                        }

                        board.appendChild(cell);
                    }
                }

                // Create token starting positions
                initializeTokens();
            }

            // Initialize tokens
            function initializeTokens() {
                gameState.tokens = {};

                // Create tokens for each player
                PLAYERS.forEach((player) => {
                    gameState.tokens[player] = [];

                    // Create 4 tokens for each player
                    for (let i = 0; i < 4; i++) {
                        const token = {
                            id: `${player}-${i}`,
                            player: player,
                            position: -1, // -1 means in starting area
                            inHome: false,
                            inHomeStretch: false,
                            homeStretchPosition: -1,
                            element: null,
                        };

                        // Create the token element
                        const tokenElement = document.createElement('div');
                        tokenElement.classList.add('token', PLAYER_COLORS[player], 'player-token', 'border', 'border-gray-800');
                        tokenElement.dataset.tokenId = token.id;
                        document.body.appendChild(tokenElement);

                        // Add click event
                        tokenElement.addEventListener('click', () => selectToken(token.id));

                        // Add to game state
                        token.element = tokenElement;
                        gameState.tokens[player].push(token);

                        // Position the token in starting area
                        const [startX, startY] = startingAreas[player][i];
                        positionTokenAt(tokenElement, startX, startY);
                    }
                });

                updateScores();
            }

            function positionTokenAt(tokenElement, x, y) {
                // Find the cell at the given coordinates
                const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                if (!cell) return;

                // Get the position of the cell
                const cellRect = cell.getBoundingClientRect();
                const boardRect = document.querySelector('.board').getBoundingClientRect();

                // Position the token in the center of the cell
                tokenElement.style.left = `${cellRect.left - boardRect.left + (cellRect.width - 20) / 2}px`;
                tokenElement.style.top = `${cellRect.top - boardRect.top + (cellRect.height - 20) / 2}px`;

                // Add the token to the board
                document.querySelector('.board').appendChild(tokenElement);
            }

            // Position a token on the main path
            function positionTokenOnPath(token) {
                let position;

                if (token.inHomeStretch) {
                    // Position on home stretch
                    const homeStretchPath = homeStretchPaths[token.player];
                    if (token.homeStretchPosition < homeStretchPath.length) {
                        const [x, y] = homeStretchPath[token.homeStretchPosition];
                        positionTokenAt(token.element, x, y);
                    } else {
                        // Token has reached home
                        token.inHome = true;
                        token.element.classList.add('opacity-50');
                        token.element.classList.remove('player-token');

                        // Position in center
                        positionTokenAt(token.element, 7, 7);

                        // Update score
                        gameState.scores[token.player]++;
                        updateScores();

                        // Check for game over
                        if (gameState.scores[token.player] === 4) {
                            gameOver(token.player);
                        } else {
                            // Player gets another roll for getting a token home
                            gameState.canRollAgain = true;
                            updateGameMessage(`${capitalizeFirstLetter(token.player)} gets another roll for getting a token home!`);
                        }
                    }
                    return;
                }

                // Position on main path
                position = token.position % 52;
                if (position >= 0 && position < mainPath.length) {
                    const [x, y] = mainPath[position];
                    positionTokenAt(token.element, x, y);
                }
            }

            // Roll the dice
            function rollDice() {
                if (!gameState.canRollAgain || gameState.gameOver) return;

                const dice = document.getElementById('dice');
                dice.classList.add('dice-rolling');
                gameState.canRollAgain = false;

                // Disable token selection during roll
                document.querySelectorAll('.player-token').forEach((token) => {
                    token.style.pointerEvents = 'none';
                });

                // Roll the dice
                setTimeout(() => {
                    gameState.diceValue = Math.floor(Math.random() * 6) + 1;
                    dice.textContent = gameState.diceValue;
                    dice.classList.remove('dice-rolling');

                    // Check if any tokens can move
                    const availableTokens = canAnyTokenMove();

                    if (availableTokens.length === 0) {
                        // No tokens can move, next player's turn
                        updateGameMessage(`No moves available for ${capitalizeFirstLetter(gameState.currentPlayer)}`);
                        setTimeout(nextPlayer, 1500);
                    } else {
                        // Enable movement for valid tokens
                        document.querySelectorAll('.player-token').forEach((token) => {
                            const tokenId = token.dataset.tokenId;
                            if (availableTokens.includes(tokenId)) {
                                token.style.pointerEvents = 'auto';
                                token.classList.add('animate-pulse');
                            } else {
                                token.style.pointerEvents = 'none';
                            }
                        });

                        if (gameState.diceValue === 6) {
                            gameState.canRollAgain = true;
                            updateGameMessage(`${capitalizeFirstLetter(gameState.currentPlayer)} rolled a 6! Move a token.`);
                        } else {
                            updateGameMessage(
                                `${capitalizeFirstLetter(gameState.currentPlayer)} rolled a ${gameState.diceValue}. Select a token to move.`,
                            );
                        }
                    }
                }, 500);
            }

            // Check which tokens can move
            function canAnyTokenMove() {
                const availableTokens = [];
                const currentPlayerTokens = gameState.tokens[gameState.currentPlayer];

                currentPlayerTokens.forEach((token) => {
                    if (token.inHome) return; // Skip tokens that are already home

                    if (token.position === -1) {
                        // Token is in starting area, can only move out with a 6
                        if (gameState.diceValue === 6) {
                            availableTokens.push(token.id);
                        }
                    } else {
                        // Token is on the board
                        if (token.inHomeStretch) {
                            // Check if token can move in home stretch
                            if (token.homeStretchPosition + gameState.diceValue <= 5) {
                                availableTokens.push(token.id);
                            }
                        } else {
                            // Check if token can enter home stretch
                            const nextPosition = token.position + gameState.diceValue;
                            const normalizedPosition = nextPosition % 52;
                            const startPos = PLAYER_START_POSITIONS[token.player];

                            // Check if token will pass its entrance to home stretch
                            if (token.position < startPos + 50 && nextPosition >= startPos + 50 && nextPosition < startPos + 56) {
                                // Token will enter home stretch
                                const homeStretchPos = nextPosition - (startPos + 50);
                                if (homeStretchPos <= 5) {
                                    availableTokens.push(token.id);
                                }
                            } else {
                                // Token will stay on main path
                                availableTokens.push(token.id);
                            }
                        }
                    }
                });

                return availableTokens;
            }

            // Select a token to move
            function selectToken(tokenId) {
                // Find the token
                let selectedToken = null;
                let selectedTokenPlayer = null;

                for (const player in gameState.tokens) {
                    for (const token of gameState.tokens[player]) {
                        if (token.id === tokenId) {
                            selectedToken = token;
                            selectedTokenPlayer = player;
                            break;
                        }
                    }
                    if (selectedToken) break;
                }

                if (!selectedToken || selectedTokenPlayer !== gameState.currentPlayer) return;

                // Move the token
                moveToken(selectedToken);

                // Remove animation from all tokens
                document.querySelectorAll('.player-token').forEach((token) => {
                    token.classList.remove('animate-pulse');
                });
            }

            // Move a token
            function moveToken(token) {
                if (token.inHome) return; // Can't move tokens that are already home

                if (token.position === -1) {
                    // Token is in starting area, can only move out with a 6
                    if (gameState.diceValue === 6) {
                        // Move token to starting position
                        token.position = PLAYER_START_POSITIONS[token.player];
                        positionTokenOnPath(token);

                        // Check if landed on another token
                        checkForCapture(token);

                        // Player gets another roll for rolling a 6
                        gameState.canRollAgain = true;
                        updateGameMessage(`${capitalizeFirstLetter(gameState.currentPlayer)} gets another roll!`);
                    }
                } else {
                    // Token is on the board
                    if (token.inHomeStretch) {
                        // Move in home stretch
                        token.homeStretchPosition += gameState.diceValue;
                        if (token.homeStretchPosition > 5) {
                            token.homeStretchPosition = 5; // Prevent going past home
                        }
                        positionTokenOnPath(token);
                    } else {
                        // Calculate new position
                        const nextPosition = token.position + gameState.diceValue;
                        const startPos = PLAYER_START_POSITIONS[token.player];

                        // Check if token will enter home stretch
                        if (token.position < startPos + 50 && nextPosition >= startPos + 50 && nextPosition < startPos + 56) {
                            // Token enters home stretch
                            token.inHomeStretch = true;
                            token.homeStretchPosition = nextPosition - (startPos + 50);
                            positionTokenOnPath(token);
                        } else {
                            // Token stays on main path
                            token.position = nextPosition;
                            positionTokenOnPath(token);

                            // Check if landed on another token
                            checkForCapture(token);
                        }
                    }
                }

                // Check if player gets another turn
                if (gameState.canRollAgain) {
                    // Player gets another roll
                    setTimeout(() => {
                        updateGameMessage(`${capitalizeFirstLetter(gameState.currentPlayer)}'s turn again!`);
                    }, 1000);
                } else {
                    // Next player's turn
                    setTimeout(nextPlayer, 1000);
                }
            }

            // Check if a token landed on another token
            function checkForCapture(token) {
                const tokenPosition = token.position % 52;

                // Check for tokens at the same position
                for (const player in gameState.tokens) {
                    if (player === token.player) continue; // Skip own tokens

                    for (const otherToken of gameState.tokens[player]) {
                        if (otherToken.inHome || otherToken.inHomeStretch) continue; // Skip tokens in home or home stretch
                        if (otherToken.position === -1) continue; // Skip tokens in starting area

                        if (otherToken.position % 52 === tokenPosition) {
                            // Capture the token
                            otherToken.position = -1;

                            // Return token to starting area
                            const tokenIndex = gameState.tokens[player].findIndex((t) => t.id === otherToken.id);
                            const [startX, startY] = startingAreas[player][tokenIndex];
                            positionTokenAt(otherToken.element, startX, startY);

                            // Player gets another roll for capturing a token
                            gameState.canRollAgain = true;
                            updateGameMessage(`${capitalizeFirstLetter(token.player)} captured a ${player} token!`);
                        }
                    }
                }
            }

            // Next player's turn
            function nextPlayer() {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % PLAYERS.length;
                gameState.currentPlayer = PLAYERS[gameState.currentPlayerIndex];
                gameState.canRollAgain = true;

                // Update UI
                document.getElementById('current-player').textContent = capitalizeFirstLetter(gameState.currentPlayer);
                document.getElementById('current-player').className = `text-${gameState.currentPlayer}-500`;

                updateGameMessage(`${capitalizeFirstLetter(gameState.currentPlayer)}'s turn. Roll the dice!`);
            }

            // Update score display
            function updateScores() {
                for (const player of PLAYERS) {
                    document.getElementById(`${player}-score`).textContent = gameState.scores[player];
                }
            }

            // Game over
            function gameOver(winner) {
                gameState.gameOver = true;
                updateGameMessage(`Game Over! ${capitalizeFirstLetter(winner)} wins! 🎉`);
            }

            // Update game message
            function updateGameMessage(message) {
                document.getElementById('game-message').textContent = message;
            }

            // Helper function to capitalize first letter
            function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }

            // Start new game
            function newGame() {
                // Reset game state
                gameState = {
                    currentPlayer: 'red',
                    currentPlayerIndex: 0,
                    diceValue: 1,
                    canRollAgain: true,
                    tokens: {},
                    scores: {
                        red: 0,
                        green: 0,
                        yellow: 0,
                        blue: 0,
                    },
                    selectedToken: null,
                    gameOver: false,
                };

                // Clear the board
                document.querySelectorAll('.token').forEach((token) => {
                    token.remove();
                });

                // Reset UI
                document.getElementById('current-player').textContent = 'Red';
                document.getElementById('current-player').className = 'text-red-500';
                document.getElementById('dice').textContent = '1';
                updateGameMessage("Red's turn. Roll the dice!");

                // Initialize board and tokens
                initializeBoard();
                updateScores();
            }

            // Event listeners
            document.getElementById('dice').addEventListener('click', rollDice);
            document.getElementById('new-game').addEventListener('click', newGame);

            // Initialize the game
            initializeBoard();
            updateGameMessage("Red's turn. Roll the dice!");
        </script>
    </body>
</html>
